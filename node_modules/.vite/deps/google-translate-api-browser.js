import "./chunk-G3PMV62Z.js";

// node_modules/google-translate-api-browser/dest/browser/esm.js
var a = { d: (e2, n2) => {
  for (var r2 in n2) a.o(n2, r2) && !a.o(e2, r2) && Object.defineProperty(e2, r2, { enumerable: true, get: n2[r2] });
}, o: (a2, e2) => Object.prototype.hasOwnProperty.call(a2, e2) };
var e = {};
a.d(e, { Ce: () => c, ZP: () => d, j1: () => r, Eb: () => o, e6: () => i, Iu: () => h });
var n = { from: "auto", to: "en", hl: "en", tld: "com", rpcids: "MkEWBc" };
function r(a2) {
  var e2 = void 0 === a2 ? {} : a2, r2 = e2.rpcids, t2 = void 0 === r2 ? n.rpcids : r2, o2 = e2.hl, i2 = void 0 === o2 ? n.hl : o2, c2 = e2.tld, s2 = void 0 === c2 ? n.tld : c2;
  if (!function(a3) {
    return Boolean(a3.match(/^[a-zA-Z]{2,63}$/));
  }(s2)) throw new Error("Invalid TLD: Must be 2-63 letters only");
  var u2 = new URLSearchParams({ rpcids: t2, "source-path": "/", hl: i2, "soc-app": "1", "soc-platform": "1", "soc-device": "1" });
  return "https://translate.google.".concat(s2, "/_/TranslateWebserverUi/data/batchexecute?").concat(u2);
}
var t = { auto: "Automatic", af: "Afrikaans", sq: "Albanian", am: "Amharic", ar: "Arabic", hy: "Armenian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", bg: "Bulgarian", ca: "Catalan", ceb: "Cebuano", ny: "Chichewa", zh: "Chinese Simplified", "zh-cn": "Chinese Simplified", "zh-tw": "Chinese Traditional", co: "Corsican", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch", en: "English", "en-US": "English", eo: "Esperanto", et: "Estonian", tl: "Filipino", fi: "Finnish", fr: "French", fy: "Frisian", gl: "Galician", ka: "Georgian", de: "German", el: "Greek", gu: "Gujarati", ht: "Haitian Creole", ha: "Hausa", haw: "Hawaiian", he: "Hebrew", iw: "Hebrew", hi: "Hindi", hmn: "Hmong", hu: "Hungarian", is: "Icelandic", ig: "Igbo", id: "Indonesian", ga: "Irish", it: "Italian", ja: "Japanese", jw: "Javanese", kn: "Kannada", kk: "Kazakh", km: "Khmer", rw: "Kinyarwanda", ko: "Korean", ku: "Kurdish (Kurmanji)", ky: "Kyrgyz", lo: "Lao", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "Macedonian", mg: "Malagasy", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mn: "Mongolian", my: "Myanmar (Burmese)", ne: "Nepali", no: "Norwegian", or: "Odia (Oriya)", ps: "Pashto", fa: "Persian", pl: "Polish", pt: "Portuguese", pa: "Punjabi", ro: "Romanian", ru: "Russian", sm: "Samoan", gd: "Scots Gaelic", sr: "Serbian", st: "Sesotho", sn: "Shona", sd: "Sindhi", si: "Sinhala", sk: "Slovak", sl: "Slovenian", so: "Somali", es: "Spanish", su: "Sundanese", sw: "Swahili", sv: "Swedish", tg: "Tajik", ta: "Tamil", tt: "Tatar", te: "Telugu", th: "Thai", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", ur: "Urdu", ug: "Uyghur", uz: "Uzbek", vi: "Vietnamese", cy: "Welsh", xh: "Xhosa", yi: "Yiddish", yo: "Yoruba", zu: "Zulu" };
var o = function(a2) {
  return Boolean(t[a2]);
};
function i(a2, e2) {
  void 0 === e2 && (e2 = false);
  var n2 = function(a3) {
    try {
      var e3 = JSON.parse(a3.replace(/^\)]}'/, ""));
      return JSON.parse(e3[0][2]);
    } catch (a4) {
      throw new Error("Data is either empty or corrupted");
    }
  }(a2), r2 = { text: n2[1][0][0][5].reduce(function(a3, e3) {
    var n3 = e3[0];
    return a3 ? "".concat(a3, " ").concat(n3) : n3;
  }, ""), pronunciation: n2[1][0][0][1], from: { language: { didYouMean: Boolean(n2[0][1]), iso: n2[2] }, text: { pronunciation: n2[0][0], autoCorrected: Boolean(n2[0][1]), value: n2[0][6][0], didYouMean: n2[0][1] ? n2[0][1][0][4] : null } } };
  return e2 && (r2.raw = n2), r2;
}
function c(a2, e2) {
  var r2 = void 0 === e2 ? {} : e2, t2 = r2.rpcids, o2 = void 0 === t2 ? n.rpcids : t2, i2 = r2.from, c2 = void 0 === i2 ? n.from : i2, s2 = r2.to, u2 = void 0 === s2 ? n.to : s2, l2 = a2.trim().replace(/["]/g, "\\\\\\$&").replace(/\r\n|\r|\n/g, "\\\\n"), h2 = encodeURIComponent('[[["'.concat(o2, '","[[\\"').concat(l2, '\\",\\"').concat(c2, '\\",\\"').concat(u2, '\\",1],[]]",null,"generic"]]]'));
  return "f.req=".concat(h2, "&");
}
var s = function() {
  return s = Object.assign || function(a2) {
    for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++) for (var t2 in e2 = arguments[n2]) Object.prototype.hasOwnProperty.call(e2, t2) && (a2[t2] = e2[t2]);
    return a2;
  }, s.apply(this, arguments);
};
var u = function(a2, e2, n2, r2) {
  return new (n2 || (n2 = Promise))(function(t2, o2) {
    function i2(a3) {
      try {
        s2(r2.next(a3));
      } catch (a4) {
        o2(a4);
      }
    }
    function c2(a3) {
      try {
        s2(r2.throw(a3));
      } catch (a4) {
        o2(a4);
      }
    }
    function s2(a3) {
      var e3;
      a3.done ? t2(a3.value) : (e3 = a3.value, e3 instanceof n2 ? e3 : new n2(function(a4) {
        a4(e3);
      })).then(i2, c2);
    }
    s2((r2 = r2.apply(a2, e2 || [])).next());
  });
};
var l = function(a2, e2) {
  var n2, r2, t2, o2, i2 = { label: 0, sent: function() {
    if (1 & t2[0]) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] };
  return o2 = { next: c2(0), throw: c2(1), return: c2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
    return this;
  }), o2;
  function c2(c3) {
    return function(s2) {
      return function(c4) {
        if (n2) throw new TypeError("Generator is already executing.");
        for (; o2 && (o2 = 0, c4[0] && (i2 = 0)), i2; ) try {
          if (n2 = 1, r2 && (t2 = 2 & c4[0] ? r2.return : c4[0] ? r2.throw || ((t2 = r2.return) && t2.call(r2), 0) : r2.next) && !(t2 = t2.call(r2, c4[1])).done) return t2;
          switch (r2 = 0, t2 && (c4 = [2 & c4[0], t2.value]), c4[0]) {
            case 0:
            case 1:
              t2 = c4;
              break;
            case 4:
              return i2.label++, { value: c4[1], done: false };
            case 5:
              i2.label++, r2 = c4[1], c4 = [0];
              continue;
            case 7:
              c4 = i2.ops.pop(), i2.trys.pop();
              continue;
            default:
              if (!((t2 = (t2 = i2.trys).length > 0 && t2[t2.length - 1]) || 6 !== c4[0] && 2 !== c4[0])) {
                i2 = 0;
                continue;
              }
              if (3 === c4[0] && (!t2 || c4[1] > t2[0] && c4[1] < t2[3])) {
                i2.label = c4[1];
                break;
              }
              if (6 === c4[0] && i2.label < t2[1]) {
                i2.label = t2[1], t2 = c4;
                break;
              }
              if (t2 && i2.label < t2[2]) {
                i2.label = t2[2], i2.ops.push(c4);
                break;
              }
              t2[2] && i2.ops.pop(), i2.trys.pop();
              continue;
          }
          c4 = e2.call(a2, i2);
        } catch (a3) {
          c4 = [6, a3], r2 = 0;
        } finally {
          n2 = t2 = 0;
        }
        if (5 & c4[0]) throw c4[1];
        return { value: c4[0] ? c4[1] : void 0, done: true };
      }([c3, s2]);
    };
  }
};
function h(a2, e2) {
  return void 0 === e2 && (e2 = {}), u(this, void 0, void 0, function() {
    var t2, o2, u2, h2, d2;
    return l(this, function(l2) {
      switch (l2.label) {
        case 0:
          return t2 = s(s({ raw: false, corsUrl: "" }, n), e2), o2 = c(a2, t2), u2 = r(t2), [4, fetch("".concat(e2.corsUrl).concat(u2), { method: "POST", headers: s({ "Content-Type": "application/x-www-form-urlencoded" }, t2.headers), body: o2 })];
        case 1:
          if (!(h2 = l2.sent()).ok) throw new Error("Request failed");
          return d2 = i, [4, h2.text()];
        case 2:
          return [2, d2.apply(void 0, [l2.sent(), t2.raw])];
      }
    });
  });
}
var d = h;
var p = e.Ce;
var f = e.ZP;
var m = e.j1;
var v = e.Eb;
var b = e.e6;
var y = e.Iu;
export {
  p as createRequestBody,
  f as default,
  m as generateRequestUrl,
  v as isLanguageSupported,
  b as normaliseResponse,
  y as translate
};
//# sourceMappingURL=google-translate-api-browser.js.map
